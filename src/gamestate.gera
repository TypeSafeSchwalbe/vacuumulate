
mod vacuumulate::gamestate

use vacuumulate::res
use vacuumulate::renderer::(CAMERA_POSITION, CAMERA_LOOK_AT, CAMERA_UP)

use std::(math, arr, iter, time, opt, str)
use std::rng::Random
use obem::(lav, input, afx, data)

pub proc create() {
    var gamestate = {
        menu = menu_hidden(),
        music_audio_source = afx::Source::new([0.0, 0.0, 0.0])
            .> loop(true)
            .> gain(10.0)
            .> play(res::BACKGROUND_TRACK .> get()),
        rng = Random::new(time::now_utc()),
        robot = {
            position = [0.0, 0.0, 0.0],
            rotation = 0.0,
            update = || {},
            audio_source = afx::Source::new([0.0, 0.0, 0.0])
        },
        update_collectables = true,
        debris = [],
        obstacles = [],
        smoke = [],
        explosion = #none unit,
        score = 0
    }
    gamestate.menu = menu_start(gamestate)
    gamestate |> add_debris(5)
    return gamestate
}

proc reset_gamestate(gamestate) {
    gamestate.robot = {
        position = [0.0, 0.0, 0.0],
        rotation = 0.0,
        update = || {},
        audio_source = afx::Source::new([0.0, 0.0, 0.0])
    }
    gamestate.robot.update = robot_movement(gamestate.robot)
    gamestate.update_collectables = true
    gamestate.debris = []
    gamestate.obstacles = []
    gamestate.smoke = []
    gamestate.explosion = #none unit
    gamestate.score = 0
    gamestate |> add_debris(5)
}

proc menu_start(gamestate) {
    return {
        title = "Vacuumulate",
        prompt = "Use the arrow keys to rotate the robot. Click anywhere to begin.",
        update = || {
            case input::mouse_button(input::MOUSE_LEFT) -> {
                gamestate.robot.update = robot_movement(gamestate.robot)
                gamestate.menu = menu_hidden()
            }
        }
    }
}

proc menu_hidden() {
    return {
        title = "",
        prompt = "",
        update = || {}
    }
}

proc menu_game_over(gamestate) {
    return {
        title = "That was too big.",
        prompt = "Click anywhere to try again.",
        update = || {
            case input::mouse_button(input::MOUSE_LEFT) -> {
                gamestate |> reset_gamestate()
                gamestate.menu = menu_hidden()
            }
        }
    }
}

proc in_room(pos, radius) {
    return pos[0] - radius > -10.0
        && pos[0] + radius < 10.0
        && pos[2] - radius > -5.0
        && pos[2] + radius < 5.0
}

var ROBOT_TURN_SPEED = 1.0
var ROBOT_MOVEMENT_SPEED = 1.5

proc robot_direction(robot) {
    return [
        math::cos(robot.rotation), 
        0.0, 
        math::sin(robot.rotation)
    ]
}

proc robot_movement(robot) {
    return || {
        case input::key(input::KEY_ARROW_LEFT) -> {
            robot.rotation = robot.rotation
                + ROBOT_TURN_SPEED * obem::delta_time()
        }
        case input::key(input::KEY_ARROW_RIGHT) -> {
            robot.rotation = robot.rotation
                - ROBOT_TURN_SPEED * obem::delta_time()
        }
        var velocity = robot
            |> robot_direction()
            |> lav::scale(ROBOT_MOVEMENT_SPEED)
            |> lav::scale(obem::delta_time())
        robot.position = robot.position
            |> lav::add(velocity)
        robot.audio_source .> position(robot.position)
        case !in_room(robot.position, 0.6) -> {
            robot.update = robot_reversal(robot)
        }
    }
}

proc robot_reversal(robot) {
    var start_time = time::now_utc()
    var duration = 2 |> time::seconds()
    var start_rotation = robot.rotation
    return || {
        var t = as_flt(time::now_utc() - start_time) / as_flt(duration)
        robot.rotation = start_rotation + t * math::PI
        case t >= 1.0 -> {
            robot.update = robot_movement(robot)
            // give it a small boost so it doesn't get stuck
            robot.position = robot.position
                |> lav::add(robot |> robot_direction() |> lav::scale(0.1))
        }
    }
}

proc robot_vibrate(gamestate) {
    var robot = gamestate.robot
    var start_position = robot.position
    var start_time = time::now_utc()
    var duration = 5 |> time::seconds()
    robot.audio_source
        .> gain(10.0)
        .> play(res::VIBRATE_SOUND .> get())
    return || {
        robot.position = start_position
            |> lav::add(lav::scale([
                gamestate.rng .> flt_in(-1.0, 1.0),
                0.0,
                gamestate.rng .> flt_in(-1.0, 1.0)
            ], obem::delta_time()))
        robot.audio_source 
            .> position(robot.position)
        case time::now_utc() > start_time + duration -> {
            robot.update = robot_smoke(gamestate)
        }
    }
}

proc robot_smoke(gamestate) {
    var robot = gamestate.robot
    var start_time = time::now_utc()
    var duration = 5 |> time::seconds()
    return || {
        var next_smoke_time = start_time
            + (length(gamestate.smoke) |> time::seconds())
        case time::now_utc() > next_smoke_time -> {
            gamestate.smoke = gamestate.smoke
                |> arr::concat([create_smoke(gamestate, robot.position)])
        }
        case time::now_utc() > start_time + duration -> {
            robot.update = robot_explode(gamestate)
        }
    }
}

proc robot_explode(gamestate) {
    var robot = gamestate.robot
    gamestate.explosion = #some create_explosion(gamestate, robot.position)
    var start_time = time::now_utc()
    var duration = 2 |> time::seconds()
    return || {
        case time::now_utc() > start_time + duration -> {
            robot.update = || {}
            gamestate.menu = menu_game_over(gamestate)
        }
    }
}

proc create_debris(gamestate) {
    var position = [
        gamestate.rng .> flt_in(-9.0, 9.0),
        0.01, 
        gamestate.rng .> flt_in(-4.0, 4.0)
    ]
    var textures = [
        res::DIRT_TEXTURE,
        res::DUST_TEXTURE
    ]
    var texture_idx = as_int(gamestate.rng .> flt_in(0.0, 9999.0))
        % length(textures)
    return {
        position = position,
        rotation = gamestate.rng .> flt_in(0.0, math::TAU),
        texture = textures[texture_idx] .> get(),
        audio_source = afx::Source::new(position)
            .> pitch(gamestate.rng .> flt_in(0.8, 1.2))
            .> gain(0.5)
            .> play(res::SPAWN_SOUND .> get())
    }
}

proc add_debris(gamestate, count) {
    var added = iter::repeat_over(|| create_debris(gamestate))
        |> iter::take(count)
        |> arr::collect()
    gamestate.debris = gamestate.debris
        |> arr::concat(added)
}

proc picked_up(pos, robot) {
    var distance = robot.position
        |> lav::sub(pos)
        |> lav::len()
    return distance < 0.4
}

proc update_debris(gamestate) {
    case !gamestate.update_collectables -> return unit
    var collected = gamestate.debris
        |> arr::iter()
        |> iter::filter(|debris| picked_up(debris.position, gamestate.robot))
        |> arr::collect()
    gamestate.score = gamestate.score
        + length(collected)
    collected
        |> arr::iter()
        |> iter::for_each(|debris| debris.audio_source
            .> gain(20.0)
            .> play(res::COLLECT_SOUND .> get())
        )
    gamestate.debris = gamestate.debris
        |> arr::iter()
        |> iter::filter(|debris| !picked_up(debris.position, gamestate.robot))
        |> arr::collect()
    case length(gamestate.debris) < 5 -> {
        gamestate |> add_debris(5)
    }
}

proc create_obstacle(gamestate) {
    var position = [
        gamestate.rng .> flt_in(-9.0, 9.0),
        0.01, 
        gamestate.rng .> flt_in(-4.0, 4.0)
    ]
    var variants = [
        { model = res::APPLE_MODEL, texture = res::APPLE_TEXTURE },
        { model = res::PENCIL_MODEL, texture = res::PENCIL_TEXTURE }
    ]
    var last_variant_idx = length(gamestate.obstacles) > 0 |> std::if_else_lazy(
        || gamestate.obstacles[length(gamestate.obstacles) - 1].variant_idx,
        || 0
    )
    var variant_idx = (last_variant_idx + 1) % length(variants)
    return {
        spawn_time = time::now_utc(),
        position = position,
        rotation = gamestate.rng .> flt_in(0.0, math::TAU),
        model = variants[variant_idx].model .> get(),
        texture = variants[variant_idx].texture .> get(),
        variant_idx = variant_idx,
        audio_source = afx::Source::new(position)
            .> pitch(gamestate.rng .> flt_in(0.8, 1.2))
            .> gain(0.8)
            .> play(res::SPAWN_SOUND .> get())
    }
}

proc add_obstacles(gamestate, count) {
    var added = iter::repeat_over(|| create_obstacle(gamestate))
        |> iter::take(count)
        |> arr::collect()
    gamestate.obstacles = gamestate.obstacles
        |> arr::concat(added)
}

var OBSTACLE_COOLDOWN = 2 |> time::seconds()

proc obstacle_picked_up(o, robot) {
    return picked_up(o.position, robot)
        && time::now_utc() > o.spawn_time + OBSTACLE_COOLDOWN 
}

var OBSTACLE_FREQUENCY = 3

proc update_obstacles(gamestate) {
    case !gamestate.update_collectables -> return unit
    case gamestate.score / OBSTACLE_FREQUENCY > length(gamestate.obstacles) -> {
        gamestate |> add_obstacles(1)
    }
    var collected = gamestate.obstacles
        |> arr::iter()
        |> iter::filter(|o| obstacle_picked_up(o, gamestate.robot))
        |> arr::collect()
    collected
        |> arr::iter()
        |> iter::for_each(|o| o.audio_source
            .> gain(20.0)
            .> play(res::COLLECT_SOUND .> get())
        )
    case length(collected) > 0 -> {
        gamestate.robot.update = robot_vibrate(gamestate)
        gamestate.update_collectables = false
    }
    gamestate.obstacles = gamestate.obstacles
        |> arr::iter()
        |> iter::filter(|o| !obstacle_picked_up(o, gamestate.robot))
        |> arr::collect()
}

proc create_smoke(gamestate, position) {
    var final_position = position
        |> lav::add([
            gamestate.rng .> flt_in(-0.5, 0.5),
            0.0,
            gamestate.rng .> flt_in(-0.5, 0.5)
        ])
    return {
        position = final_position,
        audio_source = afx::Source::new(final_position)
            .> pitch(gamestate.rng .> flt_in(0.8, 1.2))
            .> gain(4.0)
            .> play(res::SMOKE_SOUND .> get())
    }
}

var SMOKE_RISE_SPEED = 0.5

proc update_smoke(gamestate) {
    gamestate.smoke |> arr::iter() |> iter::for_each(|smoke| {
        smoke.position[1] = smoke.position[1]
            + SMOKE_RISE_SPEED * obem::delta_time()
    })
}

proc create_explosion(gamestate, position) {
    return {
        position = position,
        size = 1.0,
        audio_source = afx::Source::new(position)
            .> gain(10.0)
            .> play(res::EXPLOSION_SOUND .> get())
    }
}

var EXPLOSION_GROW_SPEED = 30.0

proc update_explosion(gamestate) {
    case gamestate.explosion {
        #some explosion -> {
            case explosion.size < 5000.0 -> {
                explosion.size = explosion.size
                * (1.0 + EXPLOSION_GROW_SPEED * obem::delta_time())
            }
        }
    } else {}
}

pub var DATA_HIGHSCORE = "highscore"

proc update_highscore(gamestate) {
    case !data::has(DATA_HIGHSCORE) -> {
        gamestate.score |> as_str() |> data::store(DATA_HIGHSCORE)
    }
    case data::get(DATA_HIGHSCORE) |> str::parse_int() {
        #none -> {
            gamestate.score |> as_str() |> data::store(DATA_HIGHSCORE)
        }
        #some highscore -> {
            case highscore < gamestate.score -> {
                gamestate.score |> as_str() |> data::store(DATA_HIGHSCORE)
            }
        }
    }
}

proc configure_listener() {
    afx::Listener::position(CAMERA_POSITION)
    afx::Listener::orientation(CAMERA_LOOK_AT, CAMERA_UP)
}

pub proc update(gamestate) {
    gamestate.menu.update()
    gamestate.robot.update()
    gamestate |> update_debris()
    gamestate |> update_obstacles()
    gamestate |> update_smoke()
    gamestate |> update_explosion()
    gamestate |> update_highscore()
    configure_listener()
}