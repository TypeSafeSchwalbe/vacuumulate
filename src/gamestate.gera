
mod vacuumulate::gamestate

use vacuumulate::res

use std::(math, arr, iter, time, opt)
use std::rng::Random
use obem::lav
use obem::input

pub proc create() {
    var gamestate = {
        rng = Random::new(time::now_utc()),
        robot = {
            position = [0.0, 0.0, 0.0],
            rotation = 0.0,
            update = || {}
        },
        debris = [],
        score = 0
    }
    gamestate.robot.update = robot_movement(gamestate.robot)
    gamestate |> add_debris(100)
    return gamestate
}

proc in_room(pos, radius) {
    return pos[0] - radius > -10.0
        && pos[0] + radius < 10.0
        && pos[2] - radius > -5.0
        && pos[2] + radius < 5.0
}

var ROBOT_TURN_SPEED = 1.0
var ROBOT_MOVEMENT_SPEED = 1.5

proc robot_movement(robot) {
    return || {
        case input::key(input::KEY_ARROW_LEFT) -> {
            robot.rotation = robot.rotation
                + ROBOT_TURN_SPEED * obem::delta_time()
        }
        case input::key(input::KEY_ARROW_RIGHT) -> {
            robot.rotation = robot.rotation
                - ROBOT_TURN_SPEED * obem::delta_time()
        }
        var velocity = [
                math::cos(robot.rotation), 
                0.0, 
                math::sin(robot.rotation)
        ] |> lav::scale(ROBOT_MOVEMENT_SPEED)
            |> lav::scale(obem::delta_time())
        robot.position = robot.position
            |> lav::add(velocity)
        case !in_room(robot.position, 0.6) -> {
            robot.update = robot_reversal(robot)
        }
    }
}

proc robot_reversal(robot) {
    var start_time = time::now_utc()
    var duration = 2 |> time::seconds()
    var start_rotation = robot.rotation
    return || {
        var t = as_flt(time::now_utc() - start_time) / as_flt(duration)
        robot.rotation = start_rotation + t * math::PI
        case t >= 1.0 -> {
            robot.update = robot_movement(robot)
        }
    }
}

proc create_debris(gamestate) {
    var textures = [
        res::DIRT_TEXTURE,
        res::DUST_TEXTURE
    ]
    var texture_idx = as_int(gamestate.rng .> flt_in(0.0, 9999.0))
        % length(textures)
    return {
        position = [
            gamestate.rng .> flt_in(-9.0, 9.0),
            0.01, 
            gamestate.rng .> flt_in(-4.0, 4.0)
        ],
        rotation = gamestate.rng .> flt_in(0.0, math::TAU),
        texture = textures[texture_idx] .> get()
    }
}

proc add_debris(gamestate, count) {
    var added = iter::repeat_over(|| create_debris(gamestate))
        |> iter::take(count)
        |> arr::collect()
    gamestate.debris = gamestate.debris
        |> arr::concat(added)
}

proc picked_up(pos, robot) {
    var distance = robot.position
        |> lav::sub(pos)
        |> lav::len()
    return distance < 0.4
}

proc update_debris(gamestate) {
    var added_score = gamestate.debris
        |> arr::iter()
        |> iter::filter(|debris| picked_up(debris.position, gamestate.robot))
        |> iter::count()
    gamestate.score = gamestate.score
        + added_score
    gamestate.debris = gamestate.debris
        |> arr::iter()
        |> iter::filter(|debris| !picked_up(debris.position, gamestate.robot))
        |> arr::collect()
}

pub proc update(gamestate) {
    gamestate.robot.update()
    gamestate |> update_debris()
}