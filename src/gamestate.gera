
mod vacuumulate::gamestate

use vacuumulate::res

use std::(math, arr, iter, time, opt)
use std::rng::Random
use obem::lav
use obem::input

pub proc create() {
    var gamestate = {
        rng = Random::new(time::now_utc()),
        robot = {
            position = [0.0, 0.0, 0.0],
            rotation = 0.0,
            update = || {}
        },
        update_collectables = true,
        debris = [],
        obstacles = [],
        smoke = [],
        explosion = #none unit,
        score = 0
    }
    gamestate.robot.update = robot_movement(gamestate.robot)
    gamestate |> add_debris(20)
    return gamestate
}

proc in_room(pos, radius) {
    return pos[0] - radius > -10.0
        && pos[0] + radius < 10.0
        && pos[2] - radius > -5.0
        && pos[2] + radius < 5.0
}

var ROBOT_TURN_SPEED = 1.0
var ROBOT_MOVEMENT_SPEED = 1.5

proc robot_direction(robot) {
    return [
        math::cos(robot.rotation), 
        0.0, 
        math::sin(robot.rotation)
    ]
}

proc robot_movement(robot) {
    return || {
        case input::key(input::KEY_ARROW_LEFT) -> {
            robot.rotation = robot.rotation
                + ROBOT_TURN_SPEED * obem::delta_time()
        }
        case input::key(input::KEY_ARROW_RIGHT) -> {
            robot.rotation = robot.rotation
                - ROBOT_TURN_SPEED * obem::delta_time()
        }
        var velocity = robot
            |> robot_direction()
            |> lav::scale(ROBOT_MOVEMENT_SPEED)
            |> lav::scale(obem::delta_time())
        robot.position = robot.position
            |> lav::add(velocity)
        case !in_room(robot.position, 0.6) -> {
            robot.update = robot_reversal(robot)
        }
    }
}

proc robot_reversal(robot) {
    var start_time = time::now_utc()
    var duration = 2 |> time::seconds()
    var start_rotation = robot.rotation
    return || {
        var t = as_flt(time::now_utc() - start_time) / as_flt(duration)
        robot.rotation = start_rotation + t * math::PI
        case t >= 1.0 -> {
            robot.update = robot_movement(robot)
            // give it a small boost so it doesn't get stuck
            robot.position = robot.position
                |> lav::add(robot |> robot_direction() |> lav::scale(0.1))
        }
    }
}

proc robot_vibrate(gamestate) {
    var robot = gamestate.robot
    var start_position = robot.position
    var start_time = time::now_utc()
    var duration = 5 |> time::seconds()
    return || {
        robot.position = start_position
            |> lav::add(lav::scale([
                gamestate.rng .> flt_in(-1.0, 1.0),
                0.0,
                gamestate.rng .> flt_in(-1.0, 1.0)
            ], obem::delta_time()))
        case time::now_utc() > start_time + duration -> {
            robot.update = robot_smoke(gamestate)
        }
    }
}

proc robot_smoke(gamestate) {
    var robot = gamestate.robot
    var start_time = time::now_utc()
    var duration = 5 |> time::seconds()
    return || {
        var next_smoke_time = start_time
            + (length(gamestate.smoke) |> time::seconds())
        case time::now_utc() > next_smoke_time -> {
            gamestate.smoke = gamestate.smoke
                |> arr::concat([create_smoke(gamestate, robot.position)])
        }
        case time::now_utc() > start_time + duration -> {
            robot.update = robot_explode(gamestate)
        }
    }
}

proc robot_explode(gamestate) {
    var robot = gamestate.robot
    gamestate.explosion = #some create_explosion(gamestate, robot.position)
    return || {}
}

proc create_debris(gamestate) {
    var textures = [
        res::DIRT_TEXTURE,
        res::DUST_TEXTURE
    ]
    var texture_idx = as_int(gamestate.rng .> flt_in(0.0, 9999.0))
        % length(textures)
    return {
        position = [
            gamestate.rng .> flt_in(-9.0, 9.0),
            0.01, 
            gamestate.rng .> flt_in(-4.0, 4.0)
        ],
        rotation = gamestate.rng .> flt_in(0.0, math::TAU),
        texture = textures[texture_idx] .> get()
    }
}

proc add_debris(gamestate, count) {
    var added = iter::repeat_over(|| create_debris(gamestate))
        |> iter::take(count)
        |> arr::collect()
    gamestate.debris = gamestate.debris
        |> arr::concat(added)
}

proc picked_up(pos, robot) {
    var distance = robot.position
        |> lav::sub(pos)
        |> lav::len()
    return distance < 0.4
}

proc update_debris(gamestate) {
    case !gamestate.update_collectables -> return unit
    var added_score = gamestate.debris
        |> arr::iter()
        |> iter::filter(|debris| picked_up(debris.position, gamestate.robot))
        |> iter::count()
    gamestate.score = gamestate.score
        + added_score
    gamestate.debris = gamestate.debris
        |> arr::iter()
        |> iter::filter(|debris| !picked_up(debris.position, gamestate.robot))
        |> arr::collect()
    case length(gamestate.debris) < 20 -> {
        gamestate |> add_debris(5)
    }
}

proc create_obstacle(gamestate) {
    var variants = [
        { model = res::APPLE_MODEL, texture = res::APPLE_TEXTURE },
        { model = res::PENCIL_MODEL, texture = res::PENCIL_TEXTURE }
    ]
    var variant_idx = as_int(gamestate.rng .> flt_in(0.0, 9999.0))
        % length(variants)
    return {
        position = [
            gamestate.rng .> flt_in(-9.0, 9.0),
            0.01, 
            gamestate.rng .> flt_in(-4.0, 4.0)
        ],
        rotation = gamestate.rng .> flt_in(0.0, math::TAU),
        model = variants[variant_idx].model .> get(),
        texture = variants[variant_idx].texture .> get()
    }
}

proc add_obstacles(gamestate, count) {
    var added = iter::repeat_over(|| create_obstacle(gamestate))
        |> iter::take(count)
        |> arr::collect()
    gamestate.obstacles = gamestate.obstacles
        |> arr::concat(added)
}

proc update_obstacles(gamestate) {
    case !gamestate.update_collectables -> return unit
    case gamestate.score / 10 > length(gamestate.obstacles) -> {
        gamestate |> add_obstacles(1)
    }
    var collided = gamestate.obstacles
        |> arr::iter()
        |> iter::filter(|o| picked_up(o.position, gamestate.robot))
        |> iter::next()
        |> opt::is_some()
    case collided -> {
        gamestate.robot.update = robot_vibrate(gamestate)
        gamestate.update_collectables = false
    }
    gamestate.obstacles = gamestate.obstacles
        |> arr::iter()
        |> iter::filter(|o| !picked_up(o.position, gamestate.robot))
        |> arr::collect()
}

proc create_smoke(gamestate, position) {
    return {
        position = position
            |> lav::add([
                gamestate.rng .> flt_in(-0.5, 0.5),
                0.0,
                gamestate.rng .> flt_in(-0.5, 0.5)
            ]),
    }
}

var SMOKE_RISE_SPEED = 0.5

proc update_smoke(gamestate) {
    gamestate.smoke |> arr::iter() |> iter::for_each(|smoke| {
        smoke.position[1] = smoke.position[1]
            + SMOKE_RISE_SPEED * obem::delta_time()
    })
}

proc create_explosion(gamestate, position) {
    return {
        position = position,
        size = 1.0
    }
}

var EXPLOSION_GROW_SPEED = 30.0

proc update_explosion(gamestate) {
    case gamestate.explosion {
        #some explosion -> {
            case explosion.size < 5000.0 -> {
                explosion.size = explosion.size
                * (1.0 + EXPLOSION_GROW_SPEED * obem::delta_time())
            }
        }
    } else {}
}

pub proc update(gamestate) {
    gamestate.robot.update()
    gamestate |> update_debris()
    gamestate |> update_obstacles()
    gamestate |> update_smoke()
    gamestate |> update_explosion()
}