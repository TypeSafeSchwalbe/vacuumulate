
mod vacuumulate::gamestate

use vacuumulate::res

use std::(math, arr, iter, time, opt)
use std::rng::Random
use obem::lav
use obem::input

pub proc create() {
    var gamestate = {
        rng = Random::new(time::now_utc()),
        robot = {
            position = [0.0, 0.0, 0.0],
            rotation = 0.0,
            update = || {}
        },
        debris = [],
        obstacles = [],
        score = 0
    }
    gamestate.robot.update = robot_movement(gamestate.robot)
    gamestate |> add_debris(20)
    return gamestate
}

proc in_room(pos, radius) {
    return pos[0] - radius > -10.0
        && pos[0] + radius < 10.0
        && pos[2] - radius > -5.0
        && pos[2] + radius < 5.0
}

var ROBOT_TURN_SPEED = 1.0
var ROBOT_MOVEMENT_SPEED = 1.5

proc robot_direction(robot) {
    return [
        math::cos(robot.rotation), 
        0.0, 
        math::sin(robot.rotation)
    ]
}

proc robot_movement(robot) {
    return || {
        case input::key(input::KEY_ARROW_LEFT) -> {
            robot.rotation = robot.rotation
                + ROBOT_TURN_SPEED * obem::delta_time()
        }
        case input::key(input::KEY_ARROW_RIGHT) -> {
            robot.rotation = robot.rotation
                - ROBOT_TURN_SPEED * obem::delta_time()
        }
        var velocity = robot
            |> robot_direction()
            |> lav::scale(ROBOT_MOVEMENT_SPEED)
            |> lav::scale(obem::delta_time())
        robot.position = robot.position
            |> lav::add(velocity)
        case !in_room(robot.position, 0.6) -> {
            robot.update = robot_reversal(robot)
        }
    }
}

proc robot_reversal(robot) {
    var start_time = time::now_utc()
    var duration = 2 |> time::seconds()
    var start_rotation = robot.rotation
    return || {
        var t = as_flt(time::now_utc() - start_time) / as_flt(duration)
        robot.rotation = start_rotation + t * math::PI
        case t >= 1.0 -> {
            robot.update = robot_movement(robot)
            // give it a small boost so it doesn't get stuck
            robot.position = robot.position
                |> lav::add(robot |> robot_direction() |> lav::scale(0.1))
        }
    }
}

proc robot_crashed(robot) {
    return || {

    }
}

proc create_debris(gamestate) {
    var textures = [
        res::DIRT_TEXTURE,
        res::DUST_TEXTURE
    ]
    var texture_idx = as_int(gamestate.rng .> flt_in(0.0, 9999.0))
        % length(textures)
    return {
        position = [
            gamestate.rng .> flt_in(-9.0, 9.0),
            0.01, 
            gamestate.rng .> flt_in(-4.0, 4.0)
        ],
        rotation = gamestate.rng .> flt_in(0.0, math::TAU),
        texture = textures[texture_idx] .> get()
    }
}

proc add_debris(gamestate, count) {
    var added = iter::repeat_over(|| create_debris(gamestate))
        |> iter::take(count)
        |> arr::collect()
    gamestate.debris = gamestate.debris
        |> arr::concat(added)
}

proc picked_up(pos, robot) {
    var distance = robot.position
        |> lav::sub(pos)
        |> lav::len()
    return distance < 0.4
}

proc update_debris(gamestate) {
    var added_score = gamestate.debris
        |> arr::iter()
        |> iter::filter(|debris| picked_up(debris.position, gamestate.robot))
        |> iter::count()
    gamestate.score = gamestate.score
        + added_score
    gamestate.debris = gamestate.debris
        |> arr::iter()
        |> iter::filter(|debris| !picked_up(debris.position, gamestate.robot))
        |> arr::collect()
    case length(gamestate.debris) < 20 -> {
        gamestate |> add_debris(5)
    }
}

proc create_obstacle(gamestate) {
    var variants = [
        { model = res::APPLE_MODEL, texture = res::APPLE_TEXTURE },
        { model = res::PENCIL_MODEL, texture = res::PENCIL_TEXTURE }
    ]
    var variant_idx = as_int(gamestate.rng .> flt_in(0.0, 9999.0))
        % length(variants)
    return {
        position = [
            gamestate.rng .> flt_in(-9.0, 9.0),
            0.01, 
            gamestate.rng .> flt_in(-4.0, 4.0)
        ],
        rotation = gamestate.rng .> flt_in(0.0, math::TAU),
        model = variants[variant_idx].model .> get(),
        texture = variants[variant_idx].texture .> get()
    }
}

proc add_obstacles(gamestate, count) {
    var added = iter::repeat_over(|| create_obstacle(gamestate))
        |> iter::take(count)
        |> arr::collect()
    gamestate.obstacles = gamestate.obstacles
        |> arr::concat(added)
}

proc update_obstacles(gamestate) {
    var collided = gamestate.obstacles
        |> arr::iter()
        |> iter::filter(|o| picked_up(o.position, gamestate.robot))
        |> iter::next()
        |> opt::is_some()
    case collided -> gamestate.robot.update = robot_crashed(gamestate.robot)
    gamestate.obstacles = gamestate.obstacles
        |> arr::iter()
        |> iter::filter(|o| !picked_up(o.position, gamestate.robot))
        |> arr::collect()
    case gamestate.score / 10 > length(gamestate.obstacles) -> {
        gamestate |> add_obstacles(1)
    }
}

pub proc update(gamestate) {
    gamestate.robot.update()
    gamestate |> update_debris()
    gamestate |> update_obstacles()
}